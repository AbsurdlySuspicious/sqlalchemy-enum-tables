SqlAlchemy Enumeration Tables
=============================

SQLAlchemy has built-in ``enum.Enum`` support,
via its column type ``sqlalchemy.Enum``.
However, this type relies either on the backend's enum type,
or on a check constraints. Both of these are immutable objects,
which are a pain in the butt to modify
(only PostgreSQL supports adding values to an enum type,
and even then it doesn't support removing them).

Another often-used pattern to support enums in a database
is via a dedicated table that reflects the enum values.
This requires updating the table everytime the enum is modified,
but doing so is much simpler than replacing a type.

This package allows you to create the enum table,
and columns referencing that table, directly from
a Python enum class. It also interfaces with Alembic
to automatically add ``INSERT`` and ``DELETE`` statements
to your autogenerated migration scripts.

How to use with SqlAlchemy
--------------------------

::

	import enum
	import sqlalchemy as sa
	from sqlalchemy.ext.declarative import declarative_base
	
	import enumtables as et

	# Create the Python enumeration class
	class MyEnum(enum.Enum):
		HELLO = "HELLO"
		WORLD = "WORLD"
	
	Base = declarative_base()

	# Create the enumeration table
	# Pass your enum class and the SQLAlchemy declarative base to enumtables.EnumTable
	MyEnumTable = et.EnumTable(MyEnum, Base)

	# Create a model class that uses the enum
	class MyModel(Base):
		__tablename__ = "my_model"
		# Pass the enum table (not the enum class) to enumtables.EnumColumn
		# It replaces sqlalchemy.Column, but aside from the enum table,
		# it can take the same parameters.
		# It will automatically create a ForeignKeyConstraint referencing the enum table.
		enum_value = et.EnumColumn(MyEnumTable, primary_key = True)

How to use with Alembic
-----------------------

Simply add::

	import enumtables

at the begining of your ``env.py`` file.
The package uses Alembic's standard hooks to take care of migration generation.

Don't forget to review the migrations afterwards.
Especially make sure of the following:

1. The class name in the ``op.insert`` and ``op.delete`` commands is the proper name of the table class
2. The table class is properly imported in the migration script
3. If the table did not exist before, the ``op.insert`` commands are located *after* the corresponding ``op.create_table`` command.