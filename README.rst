SqlAlchemy Enumeration Tables
=============================

SQLAlchemy has built-in ``enum.Enum`` support,
via its column type ``sqlalchemy.Enum``.
However, this type relies either on the backend's enum type,
or on a check constraints. Both of these are immutable objects,
which are a pain in the butt to modify
(only PostgreSQL supports adding values to an enum type,
and even then it doesn't support removing them).

Another often-used pattern to support enums in a database
is via a dedicated table that reflects the enum values.
This requires updating the table everytime the enum is modified,
but doing so is much simpler than replacing a type.

This package allows you to create the enum table,
and columns referencing that table, directly from
a Python enum class. It also interfaces with Alembic
to automatically add ``INSERT`` and ``DELETE`` statements
to your autogenerated migration scripts.

When to use
-----------

1. Only works with Pythons's enumeration classes,
   or at least one with a behavior similar to ``enum.Enum``.
   Does not work with collections of arbitrary entries.
2. Only works with SqlAlchemy's declarative ORM system.
   If you only use SqlAlchemy Core... *deal with it*.
3. Better used for frequently updated enumeration classes.
4. **Do not** use with another package that provides
   ``op.insert`` and ``op.delete`` operations in Alembic.

How to use with SqlAlchemy
--------------------------

::

    import enum
    import sqlalchemy as sa
    from sqlalchemy.ext.declarative import declarative_base
    
    import enumtables as et

    # Create the Python enumeration class
    class MyEnum(enum.Enum):
        HELLO = "HELLO"
        WORLD = "WORLD"
    
    Base = declarative_base()

    # Create the enumeration table
    # Pass your enum class and the SQLAlchemy declarative base to enumtables.EnumTable
    MyEnumTable = et.EnumTable(MyEnum, Base)

    # Create a model class that uses the enum
    class MyModel(Base):
        __tablename__ = "my_model"
        # Pass the enum table (not the enum class) to enumtables.EnumColumn
        # It replaces sqlalchemy.Column, but aside from the enum table,
        # it can take the same parameters.
        # It will automatically create a ForeignKeyConstraint referencing the enum table.
        enum_value = et.EnumColumn(MyEnumTable, primary_key = True)

How to use with Alembic
-----------------------

First add::

    import enumtables

at the begining of your ``env.py`` file,
then add the same line in the imports of your ``script.py.mako`` file.
The package uses Alembic's standard hooks to take care of migration generation.

Don't forget to review the migrations afterwards.
Especially make sure of the following:

1. The class name in the ``op.insert`` and ``op.delete`` commands is the proper name of the table class
2. The table class is properly imported in the migration script
3. If the table did not exist before, the ``op.insert`` commands are located *after* the corresponding ``op.create_table`` command.

Other uses
-----------

General purpose data migrations in Alembic
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``enumtables`` package adds two migration operations to Alembic:
``op.insert`` and ``op.delete``, used for an SQL ``INSERT`` and ``DELETE`` respectively.

Both take the ORM class as a first parameter, and a list of dictionnaries as the second.
Each dictionnary will produce an ``INSERT`` or ``DELETE`` statement
where the keys are the columns and the values are the values.

For instance ``op.insert(MyEnumTable, [{"item_id" : "HELLO"}, {"item_id" : "WORLD"}]``
with the ``MyEnumTable`` from the example above will produce:

.. code-block:: sql

    INSERT INTO my_enum (item_id) VALUES ('HELLO');
    INSERT INTO my_enum (item_id) VALUES ('WORLD');

and ``op.delete(MyEnumTable, [{"item_id" : "HELLO"}, {"item_id" : "WORLD"}]``
will produce:

.. code-block:: sql

    DELETE FROM my_enum WHERE item_id = 'HELLO';
    DELETE FROM my_enum WHERE item_id = 'WORLD';

Note that there is no operation to produce an ``UPDATE`` statement
because the main purpose of this package is not to provide data migration,
but to handle enumerations tables, and ``UPDATE`` is not needed for that purpose.

Using the enum table class directly
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The enum table class behaves like any SqlAlchemy ORM class::

    enum_query = session.query(MyEnumTable)
    result = enum_query.first()

    # The column item_id stores the name of the enum item as a string
    enum_name = result.item_id

Adding more columns to the enum tables
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Any keyword argument passed to the ``EnumTable`` factory becomes a member of the table class.
Which means, you can pass anything (like a column) exactly as you would defined a usual ORM class::

    BetterEnumTable = et.EnumTable(
        MyEnum,

        # tablename is turned into __tablename__
        tablename = "better_enum",

        # Let's add a new column!
        order = sa.Column(sa.Integer, nullable = False),

        # And since it's an ordering number, let's make it unique too.
        __table_args__ = (
            sa.UniqueConstraint('order'),
        ),
    )